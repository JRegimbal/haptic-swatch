import numpy as np
from .crediters import UniformCrediter as UniformCrediter
from .networks import DTAMERLoss as DTAMERLoss, ReLUNet as ReLUNet
from .tiling import TilingDensity as TilingDensity
from _typeshed import Incomplete

PARAM_EPSILON: float
PARAM_ALPHA: float
PARAM_BETA: int
PARAM_C: float

def and_op(x, y): ...

class BaseAgent:
    state: Incomplete
    state_lows: Incomplete
    state_highs: Incomplete
    def __init__(self, ndims: int, step: float, *args) -> None: ...
    def set_state(self, state: tuple[float, ...] | np.ndarray, *, lows: Incomplete | None = None, highs: Incomplete | None = None, action: Incomplete | None = None, history: bool = True) -> np.ndarray: ...
    def to_action(self, action: int) -> np.ndarray: ...
    def apply_action(self, action: int) -> None: ...
    def update_activation(self, dimension: int, activation: bool): ...

class NeuralSGDAgent(BaseAgent):
    crediter: Incomplete
    tiling: Incomplete
    replay: Incomplete
    def __init__(self, ndims: int, step: float, epsilon=..., alpha=..., crediter=..., replay: bool = True) -> None: ...
    def set_state(self, state: tuple[float, ...] | np.ndarray, *, lows: Incomplete | None = None, highs: Incomplete | None = None, action: Incomplete | None = None, history: bool = True): ...
    def select_epsilon_greedy_action(self) -> int | None: ...
    def replay_from_history(self) -> None: ...
    def process_guiding_reward(self, reward: float, _: int | None): ...
    def select_less_explored(self, n_points: int = 50) -> np.ndarray: ...

class SplitNeuralSGDAgent(NeuralSGDAgent):
    crediter: Incomplete
    crediter1: Incomplete
    crediter2: Incomplete
    def __init__(self, ndims1: int, ndims2: int, step: float, epsilon=..., alpha=..., crediter=..., replay: bool = True) -> None: ...
    def split(self, value: np.ndarray) -> tuple[np.ndarray, np.ndarray]: ...
    def set_state(self, state: tuple[float, ...] | np.ndarray, *, lows: Incomplete | None = None, highs: Incomplete | None = None, action: Incomplete | None = None, history: bool = True): ...
    def replay_from_history(self) -> None: ...
    def process_guiding_reward(self, reward: float, modality: int | None): ...
